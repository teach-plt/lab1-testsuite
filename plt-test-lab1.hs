-- Programming Language Technology (Chalmers DAT151 / GU DIT231)
-- (C) 2022-24 Andreas Abel
-- All rights reserved.

{-# LANGUAGE CPP #-}
{-# LANGUAGE TupleSections #-}

-- Switch off uninteresting warnings:
{-# OPTIONS_GHC -Wno-name-shadowing #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}

-- GHC needs -threaded

import Control.Arrow ((***))
import Control.Applicative
import Control.Monad

import Data.Char
import Data.IORef
import qualified Data.List as List
import Data.Maybe

import GHC.Paths
  ( ghc )

import System.Console.GetOpt
import System.Directory
  ( copyFile
  , createDirectoryIfMissing
  , doesDirectoryExist
  , listDirectory              -- Requires ghc â‰¥ 7.10.3
  , setCurrentDirectory
  )
import System.Environment
import System.FilePath
import System.Exit
import System.IO
import System.Process
import System.IO.Unsafe

-- * Configuration
------------------------------------------------------------------------

-- | Default good tests if no tests (neither good nor bad) are given on command line.
defaultGood :: [FilePath]
defaultGood = ["good", "good-CMM"]

-- | Default bad test if no tests (neither good nor bad) are given on command line.
defaultBad :: [FilePath]
defaultBad = ["bad"]

-- * Components
------------------------------------------------------------------------

{-# NOINLINE doDebug #-}
doDebug :: IORef Bool
doDebug = unsafePerformIO $ newIORef False

-- | Print debug message if debug is set to @True@.
debug :: String -> IO ()
debug s = do
  d <- readIORef doDebug
  when d $ putStrLn s

-- | Get @.cc@ files in given directory (non-recursively) in alphabetical order.
listCCFiles :: FilePath -> IO [FilePath]
listCCFiles dir
  = map (dir </>)
  . List.sort
  . filter ((".cc" ==) . takeExtension)
  <$> listDirectory dir


welcome :: IO ()
welcome = do
  putStrLn $ "This is the test program for Programming Languages Lab 1"
  putStrLn $ color red $ "NOTE: The start category in your grammar must be called 'Program'"

-- | Run @bnfc@ and return the number of rules of the grammar.
runBNFC :: String -> IO Int
runBNFC grammar = do
  (out,_) <- runPrgNoFail "bnfc" ["-d"] $ grammar <.> "cf"
  -- Look for line "nnn rules accepted"
  return $ case grep "rules accepted" out of
            []   -> 0
            l:_  -> read $ takeWhile isDigit l

runAlex :: String -> IO ()
runAlex grammar = runPrgNoFail_ "alex" [] $ grammar </> "Lex.x"

runHappy :: String -> IO [String]
runHappy grammar = do
  (_,err) <- runPrgNoFail "happy" ["-i"] $ grammar </> "Par.y"
  return $ grep "conflict" err

writeDriver :: String -> IO ()
writeDriver grammar = writeFile "testdriver.hs" $ unlines
  [ "-- testdriver generated by plt-test-lab1"
  , ""
  , "import System.IO (stderr, hPutStrLn)"
  , "import System.Environment (getArgs)"
  , ""
  , "import " ++ grammar ++ ".Par (myLexer, pProgram)"
  , ""
  , "parse s = case pProgram (myLexer s) of"
  , "  Left  err  -> hPutStrLn stderr \"ERROR\" >> hPutStrLn stderr err"
  , "  Right tree -> hPutStrLn stderr \"OK\""
  , ""
  , "main = do"
  , "  [file] <- getArgs"
  , "  readFile file >>= parse"
  ]

compileDriver :: IO ()
#ifdef HC_OPTS
compileDriver = runPrgNoFail_ ghc (["--make"] ++ words HC_OPTS ++ ["-o", "testdriver"]) "testdriver.hs"
#else
compileDriver = runPrgNoFail_ ghc ["--make", "-o", "testdriver"] "testdriver.hs"
#endif

type TestSuite = ([FilePath],[FilePath])

runTests :: TestSuite -> IO ([(FilePath,Bool)],[(FilePath,Bool)])
runTests (goodProgs,badProgs) = do
  good <- mapM (\f -> (f,) <$> testFrontendProg True  f) goodProgs
  bad  <- mapM (\f -> (f,) <$> testFrontendProg False f) badProgs
  return (good,bad)


testFrontendProg :: Bool -> FilePath -> IO Bool
testFrontendProg good f = do
  let bad = not good
      -- For some reason this executable name, without .exe, works on Windows;
      -- I think this is because we are in the same directory as the executable
      prg = "." </> "testdriver"
  putStr $ "Parsing " ++ f ++ "... "
  -- TODO: Should maybe check exit code here
  (s, out, err) <- readProcessWithExitCode prg [f] ""
  putStrLnExitCode s "."
  case lines err of
    "OK":_    | good -> return True
              | bad  -> False <$ reportError prg "passed BAD program" (Just f) Nothing out err

    "ERROR":_ | good -> False <$ reportError prg ""                   (Just f) Nothing out err

              | bad  -> return True
    _                -> False <$ reportError prg "invalid output"     (Just f) Nothing out err


--
-- * Main
--

data Options = Options
  { optDebug :: Bool        -- ^ Print debug information?
  , optGood  :: [FilePath]  -- ^ Good tests.
  , optBad   :: [FilePath]  -- ^ Bad tests.
  }

defaultOptions :: Options
defaultOptions = Options
  { optDebug = False
  , optGood  = []
  , optBad   = []
  }

optDescr :: [OptDescr (Options -> Options)]
optDescr =
  [ Option []    ["debug"] (NoArg  enableDebug       ) "print debug messages"
  , Option ['g'] ["good"]  (ReqArg addGood     "PATH") "good test case PATH"
  , Option ['b'] ["bad"]   (ReqArg addBad      "PATH") "bad test case PATH"
  ]

enableDebug :: Options -> Options
enableDebug o = o { optDebug = True }

addGood, addBad :: FilePath -> Options -> Options
addGood f o = o { optGood = f : optGood o }
addBad  f o = o { optBad  = f : optBad  o }

-- | If no test cases are given, assume standard test suites.
testSuiteOption :: Options -> TestSuite
testSuiteOption o = if null g && null b then (defaultGood, defaultBad) else (g, b)
  where
  g = optGood o
  b = optBad  o

parseArgs :: [String] -> IO (FilePath,TestSuite)
parseArgs argv = case getOpt RequireOrder optDescr argv of

  (o,[cfFile],[]) -> do
    let options = foldr ($) defaultOptions o
    when (optDebug options) $ writeIORef doDebug True
    let expandPath f = doesDirectoryExist f >>= \b -> if b then listCCFiles f else return [f]
    testSuite' <- bothM ((concat <$>) . mapM expandPath) $ testSuiteOption options
    return (cfFile, testSuite')

  (_,_,_) -> do
    hPutStrLn stderr usage
    exitFailure

  where
  bothM :: Applicative f => (a -> f b) -> (a,a) -> f (b,b)
  bothM f (a1,a2) = (,) <$> f a1 <*> f a2

usage :: String
usage = unlines
  [ "Usage: plt-test-lab1 [OPTIONS] FILE"
  , ""
  , "Test a parser given by LBNF grammar FILE to accept given good inputs and reject given bad inputs as provided by the OPTIONS."
  , ""
  , usageInfo "OPTIONS:" optDescr
  , "Any PATH that is a directory is expanded to PATH/*.cc."
  , "If neither good nor bad test cases are given, the default is: "  ++ defaultSuite
  ]
  where
  defaultSuite = unwords $ concat
    [ concatMap (\ f -> ["-g", f]) defaultGood
    , concatMap (\ f -> ["-b", f]) defaultBad
    ]

mainOpts :: FilePath -> TestSuite -> IO ()
mainOpts cfFile testSuite = do
  welcome

  -- The tests will run in a dedicated directory
  -- whose name will hopefully not clash with
  -- any files the user has.
  let dir = "lab1-test-dir#"
  createDirectoryIfMissing True dir

  -- We copy the user-provided grammar file into the directory
  -- as .cf file with the stem of the user's file.
  let grammar = takeBaseName cfFile
  copyFile cfFile $ dir </> grammar <.> "cf"

  -- We change into the working directory.
  -- Files of the testsuite with a relative name need to be updated by "../".
  setCurrentDirectory dir
  let adjustPath f = if isRelative f then ".." </> f else f
      testSuite'   = (map adjustPath *** map adjustPath) testSuite

  -- Generate the Happy parser.
  rules <- runBNFC grammar
  runAlex grammar
  msgs <- runHappy grammar

  -- Write a small wrapper program to execute the parser.
  writeDriver grammar
  compileDriver

  -- Run the wrapper program on the tests.
  (good,bad) <- runTests testSuite'

  -- Report the results.
  putStrLn ""
  putStrLn "------------------------------------------------------------"
  putStrLn $ color (if rules > 150 then red else black) $ "Number of rules:         " ++ show rules
  unless (null msgs) $ do
    mapM_ (putStrLn . color blue) msgs
    putStrLn $ "See " ++ joinPath [dir, grammar, "Par.info"]
               ++ " for information about the conflicts"
  putStrLn "------------------------------------------------------------"
  report "Good programs: " good
  report "Bad programs:  " bad

main :: IO ()
main = setup >> getArgs >>= parseArgs >>= uncurry mainOpts

-- | In various contexts this is guessed incorrectly
setup :: IO ()
setup = hSetBuffering stdout LineBuffering

--
-- * List utilities
--

-- | Return lines of second argument that contain the first argument.
grep :: String -> String -> [String]
grep x = filter (x `List.isInfixOf`) . lines

--
-- * Terminal output colors
--

type Color = Int

color :: Color -> String -> String
#if defined(mingw32_HOST_OS)
color _ s = s
#else
color c s
  | haveColors = fgcol c ++ s ++ normal
  | otherwise  = s
#endif

-- | Colors are disabled if the terminal does not support them.
{-# NOINLINE haveColors #-}
haveColors :: Bool
haveColors = unsafePerformIO supportsPretty

highlight, bold, underline, normal :: String
highlight = "\ESC[7m"
bold      = "\ESC[1m"
underline = "\ESC[4m"
normal    = "\ESC[0m"

fgcol, bgcol :: Color -> String
fgcol col = "\ESC[0" ++ show (30+col) ++ "m"
bgcol col = "\ESC[0" ++ show (40+col) ++ "m"

red, green, blue, black :: Color
black = 0
red   = 1
green = 2
blue  = 4

--
-- * Run programs
--

runPrgNoFail_
  :: FilePath -- ^ Executable
  -> [String] -- ^ Flags
  -> FilePath -- ^ Filename
  -> IO ()    -- ^ (Output truncated.)
runPrgNoFail_ exe flags file = () <$ runPrgNoFail exe flags file

runPrgNoFail
  :: FilePath            -- ^ Executable
  -> [String]            -- ^ Flags
  -> FilePath            -- ^ Filename
  -> IO (String, String) -- ^ stdout and stderr
runPrgNoFail exe flags file = do
  let c = showCommandForUser exe (flags ++ [file])
  hPutStr stderr $ "Running " ++ c ++ "... "
  (s,out,err) <- readProcessWithExitCode exe (flags ++ [file]) ""
  hPutStrLnExitCode s stderr "."
  case s of
    ExitFailure x -> do
      reportError exe ("with status " ++ show x) (Just file) Nothing out err
      exitFailure
    ExitSuccess -> do
      debug $ "Standard output:\n" ++ out
      debug $ "Standard error:\n" ++ err
      return (out,err)

--
-- * Error reporting and output checking
--

colorExitCode :: ExitCode -> String -> String
colorExitCode ExitSuccess     = color green
colorExitCode (ExitFailure _) = color red

putStrLnExitCode :: ExitCode -> String -> IO ()
putStrLnExitCode e = putStrLn . colorExitCode e

hPutStrLnExitCode :: ExitCode -> Handle -> String -> IO ()
hPutStrLnExitCode e h = hPutStrLn h . colorExitCode e

reportErrorColor
  :: Color
  -> String         -- ^ command that failed
  -> String         -- ^ how it failed
  -> Maybe FilePath -- ^ source file
  -> Maybe String   -- ^ given input
  -> String         -- ^ stdout output
  -> String         -- ^ stderr output
  -> IO ()
reportErrorColor col c m f i o e = do
    putStrLn $ color col $ c ++ " failed: " ++ m
    mapM_ prFile f
    forM_ i $ \ i -> do
      putStrLn "Given this input:"
      putStrLn $ color blue $ if null i then "<nothing>" else i
    unless (null o) $ do
      putStrLn "It printed this to standard output:"
      putStrLn $ color blue o
    unless (null e) $ do
      putStrLn "It printed this to standard error:"
      putStrLn $ color blue e

reportError
  :: String         -- ^ command that failed
  -> String         -- ^ how it failed
  -> Maybe FilePath -- ^ source file
  -> Maybe String   -- ^ given input
  -> String         -- ^ stdout output
  -> String         -- ^ stderr output
  -> IO ()
reportError = reportErrorColor red

prFile :: FilePath -> IO ()
prFile f = do
  putStrLn $ "---------------- begin " ++ f ++ " ------------------"
  s <- readFile f
  let ls = lines s
      n  = length $ show $ length ls
      s' = unlines $ zipWith (\ i l -> rightAlign n (show i) ++ ": " ++ l) [(1 :: Integer)..] ls
  putStrLn $ color green s'
  putStrLn $ "----------------- end " ++ f ++ " -------------------"

rightAlign :: Int -> String -> String
rightAlign w s = replicate (w - length s) ' ' ++ s

-- | Report how many tests passed and which tests failed (if any).
report :: String -> [(FilePath,Bool)] -> IO ()
report n rs = do
  let (passedTests,failedTests) = List.partition snd rs
      (p,t) = (length passedTests, length rs)
      successful = p == t
      c = if successful then green else red
  putStrLn $ color c $
           n ++ "passed " ++ show p ++ " of " ++ show t ++ " tests"
  when (not successful) $ do
    putStrLn $ show (t - p) ++ " tests failed:"
    forM_ failedTests $ \(fp,_) -> putStrLn $ "- " ++ fp


-- Inlined from https://hackage.haskell.org/package/pretty-terminal-0.1.0.0/docs/src/System-Console-Pretty.html#supportsPretty :

-- | Whether or not the current terminal supports pretty-terminal
supportsPretty :: IO Bool
supportsPretty =
  hSupportsANSI stdout
  where
    -- | Use heuristics to determine whether the functions defined in this
    -- package will work with a given handle.
    --
    -- The current implementation checks that the handle is a terminal, and
    -- that the @TERM@ environment variable doesn't say @dumb@ (whcih is what
    -- Emacs sets for its own terminal).
    hSupportsANSI :: Handle -> IO Bool
    -- Borrowed from an HSpec patch by Simon Hengel
    -- (https://github.com/hspec/hspec/commit/d932f03317e0e2bd08c85b23903fb8616ae642bd)
    hSupportsANSI h = (&&) <$> hIsTerminalDevice h <*> (not <$> isDumb)
      where
        isDumb = (== Just "dumb") <$> lookupEnv "TERM"
